; Scythe's AutoMiner Script
; 2024
;
; When I was eleven, I watched my dad attempt to create an autominer script
; in EasyUO back in 2001. I thought it was magic, and I wanted to learn how
; to do it myself. I did not at the time, but I kept that passion for coding
; and finally got a chance in college to take a programming course. I have since
; gotten my masters in software engineering, and I am currently a senior software
; developer and team lead. This project is me coming full circle and realizing
; my first project that I ever wanted to complete. If you are reading this, I
; hope that you get the chance like I have to attain your dreams.
;
; Note: I have done this many times before in other client assistants. I am doing
; this in a specific way that I saw my dad attempt as far as I can remember what
; he was doing. This means a few things:
;    - This is *not* going to be the most efficient thing. It is not a recall
;      miner script where you can get the best color ore as quickly as possible.
;    - It is going to need to use the Delucia area because that's where he was.
;    - I am also going to use pack animals and walking. This is going to greatly
;      increase the things that can go wrong as you have to worry about pathing
;      and also the happiness of the pack animals.


event sysMessage Starting the autominer script!

set %bank_serial YPJRJMD
set %bank_box C_ , %bank_serial
set %backpack C_ , #BACKPACKID

; Note, small pile is first. Important for combining ore later.
set %ore_pile_graphics |
  +TVJ|
  +GWJ|
  +EWJ|
  +DWJ|

str Count %ore_pile_graphics |
set %ore_pile_graphics_len #strRes - 1

set %locations |
  +5279,3968|
  +5280,3968|
  +5288,3969|
  +5294,3972|
  +5299,3966|
  +5292,3966|
  +5289,3958|
  +5283,3963|
  +5283,3957|
  +5272,3961|
  +5273,3955|
  +5271,3955|
  +5264,3960|
  +5263,3955|
  +5255,3955|
  +5249,3961|
  +5239,3956|
  +5241,3956|
  +5251,3947|
  +5242,3947|
  +5244,3942|
  +5249,3938|
  +5246,3935|
  +5253,3924|
  +5247,3925|
  +5253,3929|
  +5245,3921|
  +5231,3929|
  +5219,3938|
  +5204,3927|
  +5203,3930|
  +5202,3937|
  +5199,3942|
  +5210,3941|
  +5209,3953|
  +5197,3954|
  +5197,3961|

str Count %locations |
set %locations_len #strRes - 1

set %ore_colors |
  +0|
  +2419|
  +2406|
  +2413|
  +2418|
  +2213|
  +2425|
  +2207|
  +2219|

str Count %ore_colors |
set %ore_colors_len #strRes - 1

; %1: X Coordinate Offset
; %2: Y Coordinate Offset
sub clickGumpXY
  set %click_pos_x #CONTPOSX + %1
  set %click_pos_y #CONTPOSY + %2
  click %click_pos_x %click_pos_y
return

; %1: Object ID
; %2: Target Kind
sub useObject
  event sysMessage Using object %1
  set #LOBJECTID %1
  set #LTARGETID %1

  event Macro 17
return

; %1 : X Coordinate
; %2 : Y Coordinate
sub targetGroundXY
  set #LTARGETX %1
  set #LTARGETY %2
  ;set #LTARGETZ -1
  set #LTARGETKIND 2
  
  event Macro 22
return

; %1: Object ID
sub targetObject
  set #LTARGETKIND 1
  set #LTARGETID %1
  set #LOBJECTID %1

  event Macro 22
return

sub ensureAtStartingPosition
  ; We must ensure that our character is located in an area where they will not
  ; get stuck on any surrounding buildings.
  ; The area that we are checking for is the rectangle on the east-side of the
  ; delucia bank between the bank and the hut.
  event sysMessage Ensuring character is at starting position

  set %xStartLowerBound 5278
  set %yStartLowerBound 3971
  set %xStartUpperBound 5280
  set %yStartUpperBound 3987

  if ( #CHARPOSX > %xStartUpperBound ||
     + #CHARPOSX < %xStartLowerBound ||
     + #CHARPOSY > %yStartUpperBound ||
     + #CHARPOSY < %yStartLowerBound )
  {
    event sysMessage Please move your character to the east side of the delucia bank and restart.
    stop
  }

  event sysMessage Character was within the starting bounds. Ready to start!
return

sub checkForPackAnimals
  ; Asks the user to select their pack animals so that we know
  ; to hold their state and check their packs.

  ; if we do not have any followers, do not even have to ask.
  if #followers = 0
  {
    event sysMessage You did not have any followers, skipping pack animal check.
  }
return

; Gets the substring between separators
; %1: Search string
; %2: Index
; %3; Seperator (defaults to |)
sub getIndex
{
  ; TODO: Figure out how I want to handle default variables
  ;   and make it so that the sep can be defaulted.
  set %sep |

  str Count %1 %sep
  set %sep_count #strRes

  set %first_sep_index %2
  set %second_sep_index 1 + %2

  str Pos %1 %sep %first_sep_index
  set %first_sep_pos #strRes

  str Pos %1 %sep %second_sep_index
  set %second_sep_pos #strRes

  ; getting a space char after the desired string. removing with -1
  set %index_string_length %second_sep_pos - %first_sep_pos - 1

  ; for some reason, I am getting a space char here. Need to +1 to remove.
  set %first_sep_pos %first_sep_pos + 1
  ; Get the substring between separators
  str Mid %1 %first_sep_pos %index_string_length
  set %substring #strRes

  return %substring
}

sub bankOre
  ; Moves all ore piles in the player's backpack to the bank.
  ; Note: this should probably also happen to one's pack animals as well.

  event sysMessage Banking ore

  ; attempt to open the character's bank box
  event Macro 1 0 banco

  ; double-check that we have access to the bank box
    ; throw exception if we cannot access it.

  ; TODO: Add for-each container (player's backpack, pack animal packs)
  ; for each ore type
  for %ore_type_index 1 %ore_pile_graphics_len
  {
    ; Get the ore graphic id
    gosub getIndex %ore_pile_graphics %ore_type_index
    set %current_ore_type #result

    ; findItem only returns one item at a time,
    ; so we need to run this multiple times until we
    ; no longer have anymore.
    repeat
    {
      ; try to find the current ore graphic in container
      findItem %current_ore_type %backpack

      if ( #FINDCNT > 0 )
      {
        ; move it to the bank
        exevent drag #FINDID #FINDSTACK
        wait 1s
        exevent dropc %bank_serial
        wait 1s
      }
    }
    until #FINDCNT < 1
  }

  ; if we are anywhere near overweight still,
  if ( #WEIGHT + 50 >= #MAXWEIGHT )
  {
    ; then lets stop the script with an exception message
    event sysMessage Character does not have enough free space to mine. Please bank some stuff.
    stop
  }
  else
  {
    event sysMessage Finished banking ore
  }
return

sub restockMiningResources
  ; In order for us to mine, we really need to have at least one
  ; tinker's kit and 20 or so iron ingots.
  ; If the player does not have them on hand, will check the main
  ; bank container for these items.
  ; We are going to asusme that the bankbox is already open.

  ; Double-checking for tinker toolkits. If we do not have one, stop.
  finditem KTL %backpack

  if ( #FINDCNT = 0 )
  {
    event sysMessage We did not have tinker's tools. Please restock and restart.
    stop
  }

  ; Double-checking for ingots. We need at least 10.
  finditem ENK %backpack

  if ( #FINDCNT = 0 || #FINDSTACK < 20 )
  {
    event sysMessage Did not find enough ingots, attempting restock.

    finditem ENK C_ , %bank_serial

    ; If the player does not even have enough in the bank,
    if ( #FINDCNT = 0 || #FINDSTACK < 20 )
    {
      event sysMessage Did not find enough ingots in the bank, stopping.
      stop
    }
    else
    {
      event sysMessage Restocking ingots
      ; move it to the bank
      ; TODO: only grab enough to get us to 20.
      exevent drag #FINDID 20
      wait 1s
      exevent dropc #BACKPACKID
      wait 1s
    }
  }
return

; %1: Item Type
; %2: Container
; %3: Color
sub findFirstItemByColor
  set %firstItem N/A

  finditem %1 %2

  ; If we found something,
  if ( #FINDCNT > 0 )
  {
    ; for each item that we found,
    for #FINDINDEX 1 #FINDCNT
    {
      ; If the found item has the right color,
      if ( #FINDCOL = %3 )
      {
        set %firstItem #FINDID
      }
    }
  }

return %firstItem

sub combineOre
  ; for each ore color,
  for %ore_color_index 1 %ore_colors_len
  {
    gosub getIndex %ore_colors %ore_color_index
    set %ore_color #RESULT

    event sysMessage Combing ore for color: %ore_color

    ; First, we need to get a small of the ore color
    gosub findFirstItemByColor TVJ %backpack %ore_color
    set %small_ore_pile_id #RESULT

    event sysMessage small id: %small_ore_pile_id

    if %small_ore_pile_id <> N/A
    {
      for %large_pile_type 2 %ore_pile_graphics_len
      {

        gosub getIndex %ore_pile_graphics %large_pile_type
        set %ore_graphic #RESULT

        event sysMessage Searching for ore graphic: %ore_graphic

        ; There should only be one item of the type for each color,
        ; so we do not really need to for-loop here.
        gosub findFirstItemByColor %ore_graphic %backpack %ore_color
        set %bigOrePile #RESULT

        ; If we did not find one,
        if ( #FINDCNT < 1 )
        {
          continue
        }

        gosub useObject %bigOrePile

        ; wait for target
        target 5s

        ; target the little pile
        gosub targetObject %small_ore_pile_id
        wait 1s
      }
    }
  }
return

set %no_metal no_metal_here_to_mine.
set %cannot_mind can't_mine_there.
set %cannot_see cannot_be_seen.

sub miningStopMessageReceived
  scanJournal #JIndex
  set %received #FALSE

  if ( %no_metal in #JOURNAL )
  {
    set %received #TRUE
  }
  if ( %cannot_mind in #JOURNAL )
  {
    set %received #TRUE
  }
  if ( %cannot_see in #JOURNAL )
  {
    set %received #TRUE
  }

  set #RESULT %received
return %received

; %1: X Coordinate
; %2: Y Coordinate
sub mineXY
  ; Perform steps to mine a location, such as
  ; searching for tools, making them, and use
  ; them to target a location. Also cleaning up
  ; our backpack if we run out of space.
  event sysMessage Mining location: %1 %2

  set %finishedMining #FALSE

  while %finishedMining <> #TRUE
  {
    ; Before we even try to mine, we need to ensure that
    ; we have enough space in our backpack to mine.
    if #WEIGHT + 20 > #MAXWEIGHT
    {
      gosub combineOre
    }

    event sysMessage Attempting to find or make pickaxe

    gosub findOrMakePickaxe
    set %pickaxeId #RESULT

    event sysMessage Using found pickaxe
    gosub useObject %pickaxeId

    ; wait for target
    target 5s

    ; set last ground target and target ground
    gosub targetGroundXY %1 %2

    wait 1s

    gosub miningStopMessageReceived
    set %finishedMining #RESULT
  }

  ; Afterwards, we should combine the ore that we mined.
  ; This may save us some stamina while walking.
  gosub combineOre
return

; %1: X Coordinate
; %2: Y Coordinate
; %3: Radius from coordinate
sub walkToXY
  ; Using the built-in dumb move. There's a pathfinder version,
  ; but that feels overkill and also has the drawback of not
  ; stopping the script's execution while it's running. All I
  ; have to do is stay cognizant of the limitations of move
  ; and this should work just fine.

  event sysMessage Walking to point.
  move %1 %2 %3 5s
return

sub findOrMakePickaxe

  set %found_pickaxe #FALSE

  while ( ! %found_pickaxe )
  {
    ; Try to find a pickaxe to use
    finditem QPF %backpack

    if ( #FINDCNT < 1 )
    {
      ; Double-check we have enough ingots on hand,
      finditem ENK C_ , #BACKPACKID
      set %ingot_count #FINDSTACK

      ; Try to find a toolkit
      finditem KTL %backpack
      set %toolkit_id #FINDID

      if ( #FINDCNT < 1 || %ingot_count < 4 )
      {
        event sysMessage Did not find tools or enough ingots, stopping!
        stop
      }

      ; Double-click on tools by setting last target, use last target
      gosub useObject %toolkit_id

      ; Wait for the gump to appear. This is rather hard to do an actual
      ; wait, so we are just going to use seconds here. This does not
      ; happen THAT often, so it's not a huge cost to eat.
      wait 1s

      ; First, we click on the Tools category
      gosub clickGumpXY 25 110

      if ( #FINDCNT < 2 )
      {
        event sysMessage Only found one toolkit, making another.
        ; Click on tinker's toolkit button
        gosub clickGumpXY 230 128
      }
      else
      {
        event sysMessage Making a pickaxe!
        ; Click Next Page button
        gosub clickGumpXY 380 270

        wait 1s

        ; Click pickaxe button
        gosub clickGumpXY 234 191
      }

      ; The server does add a pause to the item creation here.
      ; Must wait to register that the toolkit or pickaxe are
      ; in our backpack after the creation attempt.
      wait 2s
    }
    else
    {
      set %pickaxeId #FINDID
      set %found_pickaxe #TRUE
    }
  }

return %pickaxeId

sub automine
  ; This is the main mining loop
  event sysMessage Starting to mine!

  ; This is where any initial information gathering should take place.
  gosub checkForPackAnimals

  ; while not dead,
  while #charGhost = NO
  {
    ; this is here because we can attempt to come back around,
    ; get lost, and then not be at the starting position.
    ; Also, a bit more dire. We could have been at the bank,
    ; gotten jailed, and now are no longer where we should be.
    gosub ensureAtStartingPosition

    gosub bankOre

    gosub restockMiningResources

    ; TODO add something here for feeding pets if we have them

    ; for each location,
    for %location_index 1 %locations_len
    {
      ; Pull out the info for the next location
      gosub getIndex %locations %location_index
      set %current_location_values #result

      ; For where we are, every location's x/y are going to be 4 digits.
      ; Note though that this may not be the case elsewhere!
      ; create variables for x/y coordinate
      str Left %current_location_values 4
      set %current_location_x #strRes
      str Right %current_location_values 4
      set %current_location_y #strRes

      event sysMessage walking to new point!
      gosub walkToXY %current_location_x %current_location_y 2

      ; TODO: Add check to see whether the next spot is mineable.
      ; I think I am going to add a flag to each location.
      ; W = Waypoint, M = Mineable?
      ; if next spot is mineable,
      gosub mineXY %current_location_x %current_location_y
    }
  }

return

event sysMessage Finished loading in all of the code.

gosub automine
stop
